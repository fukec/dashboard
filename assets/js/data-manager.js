/**
 * Data Manager - OPRAVENO pro spr√°vnou funkcnost
 * Verze: 3.0 - Modularn√≠ architektura - FUNKƒåN√ç
 * Autor: Dashboard System
 */

class DataManager {
    constructor(dashboardCore) {
        this.core = dashboardCore;
        this.sourceData = new Map(); // Cachovan√° data ze zdroj≈Ø
        this.loadingStates = new Map(); // Stav naƒç√≠t√°n√≠ pro jednotliv√© zdroje
        this.initialized = false;
    }

    /**
     * OPRAVENO: Spr√°vn√° inicializace
     */
    async init() {
        console.log('üìä Inicializace DataManager...');
        
        try {
            // Inicializace z√°kladn√≠ch komponent
            this.setupDefaultConfiguration();
            this.initialized = true;
            console.log('‚úÖ DataManager inicializov√°n √∫spƒõ≈°nƒõ');
        } catch (error) {
            console.error('‚ùå Chyba p≈ôi inicializaci DataManager:', error);
            throw error;
        }
    }

    /**
     * NOVƒö P≈òID√ÅNO: Nastaven√≠ v√Ωchoz√≠ konfigurace
     */
    setupDefaultConfiguration() {
        // V√Ωchoz√≠ konfigurace pro testov√°n√≠
        this.defaultConfig = {
            gasUrl: '', // Bude nastaveno u≈æivatelem
            timeout: 30000,
            retryAttempts: 3,
            mockDataEnabled: true
        };
    }

    /**
     * Naƒçten√≠ dat z datov√©ho zdroje - VYLEP≈†ENO
     */
    async loadDataSource(sourceId, sourceConfig) {
        console.log(`üì° Naƒç√≠t√°m data ze zdroje: ${sourceId}`, sourceConfig);

        // Validace konfigurace
        if (!this.validateSourceConfig(sourceConfig)) {
            throw new Error(`Neplatn√° konfigurace pro zdroj ${sourceId}`);
        }

        // Zkontroluj, zda u≈æ naƒç√≠t√°n√≠ neprob√≠h√°
        if (this.loadingStates.get(sourceId)) {
            console.log(`‚è≥ Naƒç√≠t√°n√≠ zdroje ${sourceId} ji≈æ prob√≠h√°`);
            return null;
        }

        this.loadingStates.set(sourceId, true);

        try {
            let data = null;

            switch (sourceConfig.type) {
                case 'google-sheets':
                    data = await this.loadGoogleSheetsData(sourceConfig);
                    break;
                case 'json-api':
                    data = await this.loadJsonApiData(sourceConfig);
                    break;
                case 'csv-file':
                    data = await this.loadCsvFileData(sourceConfig);
                    break;
                default:
                    throw new Error(`Nepodporovan√Ω typ datov√©ho zdroje: ${sourceConfig.type}`);
            }

            // Ulo≈æen√≠ do cache
            this.sourceData.set(sourceId, data);
            console.log(`‚úÖ Data ze zdroje ${sourceId} √∫spƒõ≈°nƒõ naƒçtena:`, data);
            return data;

        } catch (error) {
            console.error(`‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ dat ze zdroje ${sourceId}:`, error);
            throw error;
        } finally {
            this.loadingStates.set(sourceId, false);
        }
    }

    /**
     * Naƒçten√≠ dat z Google Sheets p≈ôes GAS - VYLEP≈†ENO
     */
    async loadGoogleSheetsData(sourceConfig) {
        const { gasUrl, sheetId, range, action } = sourceConfig.config || {};

        if (!gasUrl) {
            console.warn('‚ö†Ô∏è Chyb√≠ URL Google Apps Script, pou≈æ√≠v√°m mock data');
            return this.generateMockData();
        }

        if (!sheetId) {
            console.warn('‚ö†Ô∏è Chyb√≠ ID Google Sheets, pou≈æ√≠v√°m mock data');  
            return this.generateMockData();
        }

        const requestData = {
            action: action || 'dashboard',
            sheetId: sheetId,
            range: range || 'A1:Z1000'
        };

        console.log('üìä Odes√≠l√°m po≈æadavek na GAS:', requestData);

        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.defaultConfig.timeout);

            const response = await fetch(gasUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData),
                mode: 'cors',
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const textData = await response.text();
            console.log('üìä Raw response z GAS:', textData);

            // Pokus o parsov√°n√≠ JSON
            let data;
            try {
                data = JSON.parse(textData);
            } catch (parseError) {
                console.error('‚ùå Chyba p≈ôi parsov√°n√≠ JSON odpovƒõdi:', parseError);
                console.warn('‚ö†Ô∏è Pou≈æ√≠v√°m mock data kv≈Øli chybƒõ parsov√°n√≠');
                return this.generateMockData();
            }

            // Validace struktury odpovƒõdi
            if (data.error) {
                console.error(`‚ùå Chyba z GAS: ${data.error}`);
                console.warn('‚ö†Ô∏è Pou≈æ√≠v√°m mock data kv≈Øli chybƒõ z GAS');
                return this.generateMockData();
            }

            if (!data.data) {
                console.warn('‚ö†Ô∏è GAS nevr√°til ≈æ√°dn√° data, pou≈æ√≠v√°m mock data');
                return this.generateMockData();
            }

            // Vra≈• data nebo pr√°zdn√© pole
            const resultData = Array.isArray(data.data) ? data.data : [];
            console.log(`‚úÖ Naƒçteno ${resultData.length} z√°znam≈Ø z Google Sheets`);
            return resultData;

        } catch (error) {
            console.error('‚ùå Chyba p≈ôi komunikaci s Google Apps Script:', error);
            
            // Fallback na mock data
            if (error.name === 'AbortError') {
                console.warn('‚ö†Ô∏è Timeout p≈ôi naƒç√≠t√°n√≠ dat - pou≈æ√≠v√°m mock data');
            } else if (error.message.includes('fetch')) {
                console.warn('‚ö†Ô∏è Probl√©m s s√≠≈•ov√Ωm p≈ôipojen√≠m - pou≈æ√≠v√°m mock data');
            } else {
                console.warn('‚ö†Ô∏è Neoƒçek√°van√° chyba - pou≈æ√≠v√°m mock data');
            }
            
            return this.generateMockData();
        }
    }

    /**
     * Naƒçten√≠ dat z JSON API - VYLEP≈†ENO
     */
    async loadJsonApiData(sourceConfig) {
        const { apiUrl, headers, method } = sourceConfig.config || {};

        if (!apiUrl) {
            throw new Error('Chyb√≠ URL API');
        }

        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.defaultConfig.timeout);

            const fetchOptions = {
                method: method || 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    ...(headers || {})
                },
                signal: controller.signal
            };

            const response = await fetch(apiUrl, fetchOptions);
            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            return Array.isArray(data) ? data : [data];

        } catch (error) {
            console.error('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ z JSON API:', error);
            throw error;
        }
    }

    /**
     * Naƒçten√≠ dat z CSV souboru - BEZE ZMƒöNY
     */
    async loadCsvFileData(sourceConfig) {
        const { csvUrl } = sourceConfig.config || {};

        if (!csvUrl) {
            throw new Error('Chyb√≠ URL CSV souboru');
        }

        try {
            const response = await fetch(csvUrl);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const csvText = await response.text();
            return this.parseCsv(csvText);

        } catch (error) {
            console.error('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ CSV souboru:', error);
            throw error;
        }
    }

    /**
     * Parsov√°n√≠ CSV dat - BEZE ZMƒöNY
     */
    parseCsv(csvText) {
        const lines = csvText.split('\n').filter(line => line.trim());

        if (lines.length === 0) {
            return [];
        }

        // Prvn√≠ ≈ô√°dek jako hlaviƒçky
        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));

        // Zbytek jako data
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
            if (values.length === headers.length) {
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index];
                });
                data.push(row);
            }
        }

        return data;
    }

    /**
     * Generov√°n√≠ mock dat pro testov√°n√≠ - VYLEP≈†ENO
     */
    generateMockData() {
        console.log('üé≠ Generuji mock data pro testov√°n√≠...');
        
        const mockData = [];
        const categories = ['Prodej', 'Marketing', 'IT', 'HR', 'Finance'];
        const months = ['Leden', '√önor', 'B≈ôezen', 'Duben', 'Kvƒõten', 'ƒåerven'];
        const currentYear = new Date().getFullYear();

        for (let i = 0; i < 50; i++) {
            mockData.push({
                id: i + 1,
                kategorie: categories[Math.floor(Math.random() * categories.length)],
                mesic: months[Math.floor(Math.random() * months.length)],
                hodnota: Math.floor(Math.random() * 10000) + 1000,
                procenta: (Math.random() * 100).toFixed(1),
                datum: new Date(currentYear, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1).toISOString().split('T')[0],
                aktivni: Math.random() > 0.3,
                popis: `Mock z√°znam ${i + 1}`,
                trend: Math.random() > 0.5 ? 'vzestup' : 'pokles'
            });
        }

        console.log(`‚úÖ Vygenerov√°no ${mockData.length} mock z√°znam≈Ø`);
        return mockData;
    }

    /**
     * Z√≠sk√°n√≠ dat ze zdroje (z cache) - BEZE ZMƒöNY
     */
    getSourceData(sourceId) {
        const data = this.sourceData.get(sourceId);
        
        if (!data) {
            console.warn(`‚ö†Ô∏è Data pro zdroj ${sourceId} nejsou v cache`);
            return null;
        }

        return data;
    }

    /**
     * Nastaven√≠ dat do cache - BEZE ZMƒöNY
     */
    setSourceData(sourceId, data) {
        console.log(`üíæ Ukl√°d√°m data do cache pro zdroj: ${sourceId}`);
        this.sourceData.set(sourceId, data);
    }

    /**
     * Vyƒçi≈°tƒõn√≠ cache - BEZE ZMƒöNY
     */
    clearCache(sourceId = null) {
        if (sourceId) {
            console.log(`üóëÔ∏è ƒåist√≠m cache pro zdroj: ${sourceId}`);
            this.sourceData.delete(sourceId);
        } else {
            console.log('üóëÔ∏è ƒåist√≠m celou cache dat');
            this.sourceData.clear();
        }
    }

    /**
     * Agregace dat - DOKONƒåENO
     */
    aggregateData(data, aggregation) {
        if (!Array.isArray(data) || !aggregation) {
            return data;
        }

        if (!aggregation.groupBy) {
            console.warn('‚ö†Ô∏è Chyb√≠ groupBy parametr pro agregaci');
            return data;
        }

        try {
            // Seskupen√≠ podle pole
            const groups = {};
            
            data.forEach(row => {
                const groupKey = this.getFieldValue(row, aggregation.groupBy) || 'N/A';
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                groups[groupKey].push(row);
            });

            // Agregace skupin
            const result = Object.entries(groups).map(([key, groupData]) => {
                const aggregatedRow = { [aggregation.groupBy]: key };

                if (aggregation.aggregates && Array.isArray(aggregation.aggregates)) {
                    aggregation.aggregates.forEach(agg => {
                        const values = groupData
                            .map(row => this.getFieldValue(row, agg.field))
                            .filter(v => v !== null && v !== undefined && !isNaN(Number(v)))
                            .map(v => Number(v));

                        let aggregatedValue;

                        switch (agg.function?.toLowerCase()) {
                            case 'sum':
                                aggregatedValue = values.reduce((a, b) => a + b, 0);
                                break;
                            case 'average':
                            case 'avg':
                                aggregatedValue = values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
                                break;
                            case 'count':
                                aggregatedValue = groupData.length;
                                break;
                            case 'max':
                                aggregatedValue = values.length ? Math.max(...values) : 0;
                                break;
                            case 'min':
                                aggregatedValue = values.length ? Math.min(...values) : 0;
                                break;
                            default:
                                aggregatedValue = groupData.length;
                        }

                        const fieldName = `${agg.field}_${agg.function || 'count'}`;
                        aggregatedRow[fieldName] = aggregatedValue;
                    });
                } else {
                    // Z√°kladn√≠ agregace - count
                    aggregatedRow['count'] = groupData.length;
                }

                return aggregatedRow;
            });

            console.log(`‚úÖ Agregace dokonƒçena: ${result.length} skupin`);
            return result;

        } catch (error) {
            console.error('‚ùå Chyba p≈ôi agregaci dat:', error);
            return data;
        }
    }

    /**
     * Filtrov√°n√≠ dat - VYLEP≈†ENO
     */
    filterData(data, filters) {
        if (!Array.isArray(data) || !filters || filters.length === 0) {
            return data;
        }

        try {
            const filteredData = data.filter(row => {
                return filters.every(filter => {
                    const value = this.getFieldValue(row, filter.field);
                    return this.evaluateFilter(value, filter.operator, filter.value);
                });
            });

            console.log(`‚úÖ Filtrov√°n√≠ dokonƒçeno: ${filteredData.length}/${data.length} z√°znam≈Ø`);
            return filteredData;

        } catch (error) {
            console.error('‚ùå Chyba p≈ôi filtrov√°n√≠ dat:', error);
            return data;
        }
    }

    /**
     * NOVƒö P≈òID√ÅNO: Vyhodnocen√≠ filtru
     */
    evaluateFilter(value, operator, filterValue) {
        switch (operator?.toLowerCase()) {
            case 'equals':
            case '=':
                return value == filterValue;
            case 'not_equals':
            case '!=':
                return value != filterValue;
            case 'contains':
                return String(value).toLowerCase().includes(String(filterValue).toLowerCase());
            case 'greater':
            case '>':
                return Number(value) > Number(filterValue);
            case 'less':
            case '<':
                return Number(value) < Number(filterValue);
            case 'not_empty':
                return value !== null && value !== undefined && value !== '';
            case 'empty':
                return value === null || value === undefined || value === '';
            default:
                return true;
        }
    }

    /**
     * Z√≠sk√°n√≠ hodnoty z vno≈ôen√©ho objektu - BEZE ZMƒöNY
     */
    getFieldValue(obj, field) {
        if (!obj || !field) return null;
        return field.split('.').reduce((o, key) => o && o[key], obj);
    }

    /**
     * Z√≠sk√°n√≠ statistik dat - VYLEP≈†ENO
     */
    getDataStats(data) {
        if (!data) {
            return { count: 0, fields: [], types: {} };
        }

        if (Array.isArray(data)) {
            if (data.length === 0) {
                return { count: 0, fields: [], types: {} };
            }

            const fields = data.length > 0 && typeof data[0] === 'object' ? Object.keys(data[0]) : [];
            const types = {};

            // Anal√Ωza typ≈Ø dat
            fields.forEach(field => {
                const sampleValues = data.slice(0, 10).map(row => row[field]).filter(v => v !== null && v !== undefined);
                types[field] = this.detectFieldType(sampleValues);
            });

            return {
                count: data.length,
                fields: fields,
                types: types
            };
        }

        if (typeof data === 'object') {
            return {
                count: 1,
                fields: Object.keys(data),
                types: {}
            };
        }

        return { count: 0, fields: [], types: {} };
    }

    /**
     * NOVƒö P≈òID√ÅNO: Detekce typu pole
     */
    detectFieldType(values) {
        if (values.length === 0) return 'unknown';

        let numberCount = 0;
        let dateCount = 0; 
        let booleanCount = 0;

        values.forEach(value => {
            if (typeof value === 'number' || (!isNaN(Number(value)) && value !== '')) {
                numberCount++;
            } else if (this.isValidDate(value)) {
                dateCount++;
            } else if (typeof value === 'boolean' || value === 'true' || value === 'false') {
                booleanCount++;
            }
        });

        const total = values.length;
        const threshold = 0.7; // 70% threshold

        if (numberCount / total > threshold) return 'number';
        if (dateCount / total > threshold) return 'date';
        if (booleanCount / total > threshold) return 'boolean';
        
        return 'string';
    }

    /**
     * NOVƒö P≈òID√ÅNO: Validace datumu
     */
    isValidDate(value) {
        if (!value) return false;
        const date = new Date(value);
        return !isNaN(date.getTime()) && String(value).match(/\d{4}-\d{2}-\d{2}|\d{2}\/\d{2}\/\d{4}|\d{1,2}\.\d{1,2}\.\d{4}/);
    }

    /**
     * Validace konfigurace datov√©ho zdroje - VYLEP≈†ENO
     */
    validateSourceConfig(sourceConfig) {
        if (!sourceConfig || typeof sourceConfig !== 'object') {
            console.error('‚ùå Neplatn√° konfigurace datov√©ho zdroje');
            return false;
        }

        if (!sourceConfig.type) {
            console.error('‚ùå Chyb√≠ typ datov√©ho zdroje');
            return false;
        }

        if (!sourceConfig.config) {
            console.error('‚ùå Chyb√≠ konfigurace pro datov√Ω zdroj');
            return false;
        }

        // Validace podle typu
        switch (sourceConfig.type) {
            case 'google-sheets':
                // GAS URL je voliteln√© - pou≈æije se mock data
                if (sourceConfig.config.gasUrl && !sourceConfig.config.sheetId) {
                    console.warn('‚ö†Ô∏è GAS URL zad√°no, ale chyb√≠ Sheet ID');
                }
                break;
            case 'json-api':
                if (!sourceConfig.config.apiUrl) {
                    console.error('‚ùå Chyb√≠ URL API');
                    return false;
                }
                break;
            case 'csv-file':
                if (!sourceConfig.config.csvUrl) {
                    console.error('‚ùå Chyb√≠ URL CSV souboru');
                    return false;
                }
                break;
            default:
                console.error(`‚ùå Nepodporovan√Ω typ datov√©ho zdroje: ${sourceConfig.type}`);
                return false;
        }

        return true;
    }

    /**
     * Export dat do r≈Øzn√Ωch form√°t≈Ø - BEZE ZMƒöNY
     */
    exportData(data, format = 'json') {
        if (!Array.isArray(data)) {
            throw new Error('Data nejsou ve form√°tu pole');
        }

        switch (format.toLowerCase()) {
            case 'json':
                return JSON.stringify(data, null, 2);
            case 'csv':
                return this.convertToCsv(data);
            default:
                throw new Error(`Nepodporovan√Ω form√°t exportu: ${format}`);
        }
    }

    /**
     * Konverze dat do CSV - BEZE ZMƒöNY
     */
    convertToCsv(data) {
        if (data.length === 0) {
            return '';
        }

        const headers = Object.keys(data[0]);
        const csvLines = [headers.join(',')];

        data.forEach(row => {
            const values = headers.map(header => {
                const value = row[header];
                // Escape hodnoty s ƒç√°rkami nebo uvozovkami
                if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
                    return `"${value.replace(/"/g, '""')}"`;
                }
                return value;
            });
            csvLines.push(values.join(','));
        });

        return csvLines.join('\n');
    }

    /**
     * NOVƒö P≈òID√ÅNO: Z√≠sk√°n√≠ stavu inicializace
     */
    isInitialized() {
        return this.initialized;
    }

    /**
     * NOVƒö P≈òID√ÅNO: Z√≠sk√°n√≠ konfigurace
     */
    getConfiguration() {
        return { ...this.defaultConfig };
    }

    /**
     * NOVƒö P≈òID√ÅNO: Aktualizace konfigurace
     */
    updateConfiguration(newConfig) {
        this.defaultConfig = { ...this.defaultConfig, ...newConfig };
        console.log('‚öôÔ∏è Konfigurace DataManager aktualizov√°na');
    }
}

// Export pro modul syst√©m
if (typeof module !== 'undefined' && module.exports) {
    module.exports = DataManager;
}

console.log('üìä Data Manager naƒçten - OPRAVEN√Å FUNKƒåN√ç VERZE');
